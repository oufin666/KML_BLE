/*
 * my_spi.c
 *
 *  Created on: Jan 26, 2026
 *      Author: wkt98
 */
#include "main.h"
#include "spi.h"
#include "my_spi.h"

// DMA传输完成标志（0：未完成，1：完成）
uint8_t LCD_DMA_TX_Finished = 0;
uint8_t LCD_DMA_Buf_Occupied = 0; // 缓冲区占用标志（0=空闲，1=占用）



uint8_t dma_buf[BLOCK_MAX_SIZE] = {0}; // 静态缓冲区，生命周期贯穿整个程序


/******************************************************************************
 函数说明：硬件SPI数据传输函数（替换原软件模拟的LCD_Writ_Bus）
 入口数据：dat  要写入的8位数据
 返回值：无
 注意：严格匹配SPI配置（Motorola、MSB、CPOL=Low、CPHA=1 Edge）
 ******************************************************************************/
void LCD_SPI_Transmit(u8 dat) {
	// 等待SPI外设空闲
	while (HAL_SPI_GetState(&hspi1) != HAL_SPI_STATE_READY)
		;

	// 硬件SPI传输1字节数据（阻塞模式，确保传输完成）
	HAL_SPI_Transmit(&hspi1, &dat, 1, HAL_MAX_DELAY);
}

/******************************************************************************
 函数说明：SPI DMA非阻塞传输（用于大数据：填充颜色）
 入口数据：pData 数据缓冲区地址，Len 数据长度（字节数）
 返回值：无
 注意：传输期间CPU可执行其他任务，通过LCD_DMA_TX_Finished标志判断完成
 ******************************************************************************/
void LCD_SPI_Transmit_DMA(uint8_t *pData, uint16_t Len) {
	while (LCD_DMA_Buf_Occupied == 1)
		; // 缓冲区被占用，拒绝新传输
	LCD_DMA_Buf_Occupied = 1; // 标记占用
	LCD_DMA_TX_Finished = 0;
	HAL_SPI_Transmit_DMA(&hspi1, pData, Len);
}

/******************************************************************************
 函数说明：DMA传输完成回调函数（需在spi.c中调用）
 入口数据：无
 返回值：无
 ******************************************************************************/
void LCD_DMA_TX_Callback(void) {
	LCD_DMA_TX_Finished = 1;
	LCD_DMA_Buf_Occupied = 0; // 传输完成，释放缓冲区
}


/******************************************************************************
 函数说明：LCD串行数据写入函数（复用原逻辑，仅替换SPI传输部分）
 入口数据：dat  要写入的串行数据
 返回值：无
 ******************************************************************************/
void LCD_Writ_Bus(u8 dat) {
	LCD_CS_Clr();  // 拉低CS，选中LCD
	LCD_SPI_Transmit(dat);                                       // 硬件SPI传输
	LCD_CS_Set();    // 拉高CS，结束传输
}

/******************************************************************************
 函数说明：LCD写入8位数据（无修改，复用原逻辑）
 入口数据：dat 写入的数据
 返回值：无
 ******************************************************************************/
void LCD_WR_DATA8(u8 dat) {
	LCD_Writ_Bus(dat);
}

/******************************************************************************
 函数说明：LCD写入16位数据（无修改，复用原逻辑：分两次8位传输）
 入口数据：dat 写入的数据
 返回值：无
 ******************************************************************************/
void LCD_WR_DATA(u16 dat) {
	LCD_Writ_Bus(dat >> 8);  // 先传高8位（MSB）
	LCD_Writ_Bus(dat & 0xFF); // 再传低8位
}

/******************************************************************************
 函数说明：LCD写入16位数据（无修改，复用原逻辑：分两次8位传输）
 入口数据：dat 写入的数据
 返回值：无
 ******************************************************************************/
void LCD_WR_DATA_DMA(u16 dat) {
	uint8_t dma_buf[2];
	dma_buf[0] = (dat >> 8) & 0xFF;    // 高8位（先传）
	dma_buf[1] = dat & 0xFF;
	LCD_SPI_Transmit_DMA(dma_buf, 2);  // 先传高8位（MSB）再传低8位
	while (LCD_DMA_TX_Finished == 0)
		;
}

/******************************************************************************
 函数说明：LCD写入命令
 入口数据：dat 写入的命令
 返回值：  无
 ******************************************************************************/
void LCD_WR_REG(u8 dat) {
	LCD_DC_Clr(); //写命令
	LCD_Writ_Bus(dat);
	LCD_DC_Set(); //写数据
}
