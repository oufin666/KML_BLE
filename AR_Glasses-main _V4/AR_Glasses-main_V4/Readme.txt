================================================================================
                    KML文件蓝牙传输与解压系统 - 技术文档
================================================================================

一、系统概述
================================================================================
本系统实现了从微信小程序通过蓝牙串口接收压缩KML文件，并在STM32嵌入式设备上
进行流式解压的完整方案。系统采用双缓冲区机制和流式处理技术，能够高效处理大
文件而不占用过多内存。

主要特点：
- 双缓冲区DMA接收，确保数据不丢失
- 流式解压技术，内存占用低（仅需约20KB）
- 支持UTF-8多字节字符处理

二、数据接收流程（DMA双缓冲区机制）
================================================================================

2.1 硬件配置
------------
- 串口：UART1（蓝牙通信）
- 波特率：115200 bps
- DMA模式：循环模式（Circular Mode）
- 接收方式：DMA中断驱动
- GPIO配置：PA10(RX), PA15(TX)

为什么选择DMA循环模式？
  DMA有两种工作模式：
  1. 普通模式（Normal Mode）：传输完成后自动停止，需要手动重启
  2. 循环模式（Circular Mode）：传输完成后自动重新开始
  
  选择循环模式的原因：
  
  ✓ 连续接收不中断
    - 蓝牙数据流是连续的，可能随时到达
    - 循环模式确保DMA始终处于接收状态
    - 避免在重启DMA期间丢失数据
  
  ✓ 减少CPU干预
    - 普通模式需要在每次传输完成后手动重启DMA
    - 循环模式自动重启，CPU只需处理数据
    - 降低中断频率，提高系统效率
  
  ✓ 简化缓冲区管理
    - DMA硬件缓冲区（4096字节）作为环形缓冲区使用
    - 通过 __HAL_DMA_GET_COUNTER() 获取当前写入位置
    - 应用程序可以随时读取已接收的数据
  
  ✓ 防止数据溢出
    - 即使应用程序处理较慢，DMA仍在接收
    - 数据暂存在DMA缓冲区中
    - 配合双缓冲区机制，确保数据不丢失
  
  工作原理：
    DMA缓冲区：[0] [1] [2] ... [4095] -> 回到 [0]（循环）
                 ↑                ↑
              读取位置         DMA写入位置
    
    - DMA自动将串口数据写入缓冲区
    - 写入位置到达末尾后自动回到开头
    - 应用程序跟踪读取位置，避免覆盖未读数据

2.2 双缓冲区架构
----------------

系统采用两层缓冲区设计：DMA硬件缓冲区 + 应用层双缓冲区

串口数据 → DMA硬件缓冲区 → 应用缓冲区A/B → SD卡文件
          (4KB, 循环)    (4KB×2, 交替)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【第一层】DMA硬件缓冲区（DMA Buffer）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

定义：
  uint8_t dma_rx_buffers[1][4096];  // 单个4KB循环缓冲区

特点：
  ✓ 硬件直接访问
    - DMA控制器直接将串口数据写入此缓冲区
    - 无需CPU干预，零开销
    - 写入速度等于串口接收速度
  
  ✓ 循环模式
    - 写入位置到达4096后自动回到0
    - 永不停止，持续接收
    - 通过 __HAL_DMA_GET_COUNTER() 获取当前位置
  
  ✓ 临时存储
    - 数据在此短暂停留
    - 应用程序需要尽快读取
    - 如果读取太慢，新数据会覆盖旧数据
  
  ✓ 中断触发
    - 半传输中断（HT）：前2KB接收完成
    - 传输完成中断（TC）：后2KB接收完成
    - 空闲中断（IDLE）：串口空闲，处理剩余数据

作用：
  - 硬件级数据缓存
  - 解耦串口接收和CPU处理
  - 防止串口FIFO溢出

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【第二层】应用层双缓冲区（Application Buffers）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

定义：
  uint8_t app_buffers[2][4096];           // 两个4KB缓冲区
  volatile uint32_t app_buffer_index[2];  // 每个缓冲区的写入位置
  volatile uint8_t app_buffer_full[2];    // 缓冲区满标志
  volatile uint8_t current_app_buffer;    // 当前使用的缓冲区索引

特点：
  ✓ 软件管理
    - CPU从DMA缓冲区读取数据并写入应用缓冲区
    - 可以进行数据处理（如检测结束标记）
    - 写入速度取决于CPU处理速度
  
  ✓ 双缓冲机制
    - 缓冲区A接收数据时，缓冲区B可以写入SD卡
    - 缓冲区B接收数据时，缓冲区A可以写入SD卡
    - 接收和写入并行进行，互不阻塞
  
  ✓ 持久存储
    - 数据在此停留直到写入SD卡
    - 不会被覆盖
    - 写入完成后才清空
  
  ✓ 状态管理
    - app_buffer_full[i] = 0：缓冲区空闲，可以接收数据
    - app_buffer_full[i] = 1：缓冲区已满，等待写入SD卡

作用：
  - 数据预处理（结束标记检测）
  - 解耦数据接收和SD卡写入
  - 提供写入缓存，减少SD卡写入次数

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
关键区别对比
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

特性           DMA硬件缓冲区        应用层缓冲区
--------------------------------------------------------------
数量           1个                  2个
大小           4KB                  4KB × 2
访问方式       DMA硬件              CPU软件
工作模式       循环覆盖             填满后切换
数据来源       串口硬件             DMA缓冲区
数据去向       应用缓冲区           SD卡文件
速度           硬件速度(快)         软件速度(慢)
可靠性         可能被覆盖           不会被覆盖
CPU占用        0%                   需要CPU处理
数据处理       不可处理             可以处理

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
数据流转过程
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

步骤1：串口接收 → DMA缓冲区
  - 蓝牙模块发送数据到UART1
  - DMA控制器自动将数据写入 dma_rx_buffers[0]
  - 写入位置：dma_write_pos（由DMA硬件维护）
  - 无需CPU干预

步骤2：DMA缓冲区 → 应用缓冲区
  - Process_DMA_Data() 函数定期检查DMA缓冲区
  - 计算可读取的数据量：dma_write_pos - dma_read_pos
  - 逐字节读取并写入当前应用缓冲区
  - 检测结束标记（0xFF 0xFF 0xFF）
  - 缓冲区满时切换到另一个缓冲区

步骤3：应用缓冲区 → SD卡
  - BLE_KML_Task 任务检查 app_buffer_full[i]
  - 如果缓冲区满，调用 f_write() 写入SD卡
  - 写入完成后重置缓冲区：app_buffer_full[i] = 0
  - 缓冲区可以继续接收新数据

2.3 DMA接收流程
---------------
步骤1：启动DMA接收
  - 调用 UART1_Start_DMA_Reception() 启动DMA循环接收
  - DMA硬件缓冲区大小：512字节
  - DMA自动将串口数据搬运到硬件缓冲区

步骤2：DMA中断处理
  - 半传输中断（HT）：DMA缓冲区前256字节接收完成
  - 传输完成中断（TC）：DMA缓冲区后256字节接收完成
  - 空闲中断（IDLE）：串口空闲，处理剩余数据

步骤3：数据搬运到应用缓冲区
  在中断服务程序中调用 Process_DMA_Data()：
  
  a) 计算本次接收的数据量
  b) 检查是否包含结束标记（0xFF 0xFF 0xFF）
  c) 将数据从DMA缓冲区复制到当前应用缓冲区
  d) 更新 app_buffer_index[current_buffer]
  e) 如果缓冲区满（达到4096字节），设置 app_buffer_full[current_buffer] = 1
  f) 切换到另一个缓冲区继续接收

2.4 缓冲区切换逻辑
------------------
触发条件：
  1. 当前缓冲区已满（app_buffer_index >= 4096）
  2. 检测到传输结束标记（0xFF 0xFF 0xFF）

切换步骤：
  1. 设置当前缓冲区满标志：app_buffer_full[current] = 1
  2. 切换缓冲区索引：current_buffer = 1 - current_buffer
  3. 新缓冲区从位置0开始接收：app_buffer_index[new] = 0

优势：
  - 接收和写入并行进行，不阻塞数据接收
  - 避免数据丢失
  - 提高系统吞吐量

三、SD卡写入流程
================================================================================

3.1 文件系统配置
----------------
- 文件系统：FatFS
- SD卡接口：SDIO
- SDIO时钟：48MHz
- 分频系数：6（实际工作频率：8MHz）
- 堆内存分配：8312字节

3.2 文件创建
------------
目标文件：0:/kml/compressed_kml.bin

打开模式：FA_CREATE_ALWAYS | FA_WRITE
  - FA_CREATE_ALWAYS：如果文件存在则覆盖，不存在则创建
  - FA_WRITE：写入模式

3.3 写入流程（在BLE_KML_Task任务中）
------------------------------------
主循环每10ms检查一次缓冲区状态：

for (int i = 0; i < 2; i++) {
  if (app_buffer_full[i] && sd_file_opened) {
    // 步骤1：获取缓冲区数据量
    uint32_t bytes_to_write = app_buffer_index[i];
    
    // 步骤2：写入SD卡
    UINT bytes_written;
    FRESULT res = f_write(&SDFile, app_buffers[i], bytes_to_write, &bytes_written);
    
    // 步骤3：更新统计
    if (res == FR_OK) {
      total_written += bytes_written;
      
      // 步骤4：重置缓冲区状态
      app_buffer_full[i] = 0;
      app_buffer_index[i] = 0;
    }
  }
}

3.4 传输完成处理
----------------
当检测到 transfer_complete = 1 时：
  1. 写入所有剩余缓冲区数据
  2. 调用 f_sync(&SDFile) 同步文件系统
  3. 调用 f_close(&SDFile) 关闭文件
  4. 打印传输统计信息（总字节数）


四、流式解压流程
================================================================================

4.1 使用的压缩算法：自定义BL压缩算法
------------------------------------

算法名称：BL（Binary-Light）压缩算法
设计目标：专门为KML文件设计，针对GPS坐标数据优化

核心思想：
  ✓ 坐标数据压缩
    - KML文件中大量的GPS坐标占据主要空间
    - 将浮点数坐标转换为整数（乘以1000000）
    - 用12字节存储一个坐标点（原本需要30-40字节）
    - 压缩率：约70-80%
  
  ✓ 文本数据保留
    - XML标签和属性名直接保留（不压缩）
    - 保持UTF-8编码，支持中文等多字节字符
    - 便于调试和错误修复
  
  ✓ 特殊标记
    - 使用0xFE标记坐标块的开始
    - 使用0xFF 0xFF 0xFF标记文件结束
    - 使用'BL'作为文件头标识

压缩格式示例：
  原始KML：
    <coordinates>114.123456,22.654321,108.5 114.234567,22.765432,109.2</coordinates>
    （约70字节）
  
  压缩后：
    0xFE [坐标数量:2] [坐标1:12字节] [坐标2:12字节]
    （约27字节，节省60%）

4.2 解压缓冲区说明
------------------

系统使用两个缓冲区进行流式解压：

压缩文件(SD卡) → 读取缓冲区 → 解压处理 → 输出缓冲区 → 解压文件(SD卡)
                (8KB)                    (4KB)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【缓冲区1】读取缓冲区（Read Buffer）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

定义：
  uint8_t* read_buf = malloc(8192);  // 8KB读取缓冲区

作用：
  - 从SD卡批量读取压缩数据
  - 减少SD卡读取次数，提高效率
  - 作为解压的"原料仓库"

工作方式：
  1. 一次性从SD卡读取8KB压缩数据
  2. 解压程序逐字节读取并处理
  3. 读完后再从SD卡读取下一个8KB
  4. 循环往复直到文件结束

为什么是8KB？
  - 平衡内存占用和读取效率
  - 太小：频繁读取SD卡，效率低
  - 太大：占用内存多，可能分配失败
  - 8KB是经验值，适合大多数场景

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【缓冲区2】输出缓冲区（Output Buffer）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

定义：
  uint8_t* out_buf = malloc(4096);  // 4KB输出缓冲区

作用：
  - 暂存解压后的文本数据
  - 批量写入SD卡，减少写入次数
  - 作为解压的"成品仓库"

工作方式：
  1. 解压后的字符先写入输出缓冲区
  2. 缓冲区快满时（剩余空间<4字节）写入SD卡
  3. 清空缓冲区，继续接收新数据
  4. 解压完成后写出剩余数据

为什么是4KB？
  - 与应用缓冲区大小一致，便于管理
  - 足够存储大量文本数据
  - 不会太大导致内存不足

步骤2：开始翻译（主循环）
  - 从读取缓冲区拿一个字节
  - 判断这个字节是什么：
  
    情况A：遇到坐标标记(0xFE)
      → 这是一堆坐标数据的开始！
      → 读取坐标数量（比如有100个坐标）
      → 写入"<coordinates>"标签
      → 逐个处理坐标：
        - 读取12字节（经度、纬度、高度的整数形式）
        - 除以1000000转换成小数
        - 格式化成"114.123456,22.654321,108.5 "
        - 直接写入SD卡（不经过输出缓冲区）
      → 写入"</coordinates>"标签
    
    情况B：普通英文字符（0x00-0x7F）
      → 直接放入输出缓冲区
      → 如果输出缓冲区快满了，先写入SD卡
    
    情况C：中文字符（多字节UTF-8）
      → 根据第一个字节判断需要几个字节
      → 连续读取2-4个字节
      → 完整的字符放入输出缓冲区
      → 如果输出缓冲区快满了，先写入SD卡

步骤3：收尾工作
  - 把输出缓冲区剩余的数据写入SD卡
  - 关闭文件
  - 释放缓冲区内存
  - 打印统计信息（解压了多少字节）

步骤4：错误修复（可选）
  - 重新打开解压文件
  - 扫描是否有已知错误（如</Datta>）
  - 发现错误就修复
  - 关闭文件

传统解压方式：
  1. 把整个压缩文件读入内存（可能几MB）
  2. 在内存中解压
  3. 把整个解压结果写入SD卡
  
  问题：需要大量内存！如果文件太大，内存不够用

流式解压方式：
  1. 只读一小块压缩数据（8KB）
  2. 解压这一小块
  3. 写入SD卡
  4. 继续读下一小块
  
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
关键技术点（简单说明）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1. 缓冲区溢出保护
   问题：输出缓冲区只有4KB，写满了怎么办？
   解决：每次写入前检查空间，不够就先倒出去（写入SD卡）

2. 边界处理
   问题：一个中文字符3个字节，读到第2个字节时缓冲区空了怎么办？
   解决：先记住已读的字节，重新装填缓冲区，继续读剩余字节

3. 坐标格式化
   问题：114.123000这样的小数后面有多余的0
   解决：从后往前删除0，但至少保留一位（108.0不能变成108.）

4. 内存管理
   问题：12KB内存从哪来？
   解决：用malloc动态分配，用完后free释放，不浪费

4.3 解压流程详解
----------------

步骤1：初始化
  a) 打开压缩文件（compressed_kml.bin）
  b) 读取文件大小
  c) 检查并移除文件尾结束标记（0xFF 0xFF 0xFF）
  d) 验证文件头标识（'BL'）
  e) 打开输出文件（decompressed_kml.kml）
  f) 分配读取缓冲区和输出缓冲区
步骤2：主解压循环
步骤3：写出剩余数据
  if (out_pos > 0) {
    f_write(&decompressed_fd, out_buf, out_pos, &bytes_written);
  }
步骤4：关闭文件
  f_sync(&decompressed_fd);
  f_close(&decompressed_fd);
步骤5：错误修复（可选）
  重新打开文件，扫描并修复已知的错误模式：
  - </Datta> -> </Data>
  - <Datta -> <Data
  - /Data> -> </Data>
  - valulue -> value
步骤6：释放内存
  free(read_buf);
  free(out_buf);

4.4 关键技术点
--------------

4.4.1 输出缓冲区溢出保护
  问题：如果不检查缓冲区空间，写入时可能溢出导致数据丢失
  解决：每次写入前检查剩余空间，不足时先写入文件

4.4.2 读取缓冲区边界处理
  问题：多字节数据可能跨越缓冲区边界
  解决：
    - 检测到缓冲区不足时，先保存已读取的字节
    - 重新填充缓冲区
    - 继续读取剩余字节

4.4.3 UTF-8多字节字符处理
  问题：UTF-8字符可能占用1-4个字节，需要完整读取
  解决：
    - 根据首字节判断字符长度
    - 连续读取所有字节
    - 确保字符完整性

4.4.4 坐标数据格式化
  问题：浮点数转字符串后有多余的尾部0
  解决：
    - 使用snprintf格式化为6位小数
    - 从末尾向前扫描，移除多余的0
    - 保留至少一位小数（例如：108.0）


五、数据完整性保障
================================================================================

5.1 CRC32校验
-------------
算法：CRC-32/ISO-HDLC
多项式：0xEDB88320
初始值：0xFFFFFFFF
最终异或：0xFFFFFFFF

校验流程：
  1. 小程序端计算压缩数据的CRC32值
  2. 通过蓝牙发送CRC32值（4字节）
  3. STM32接收完数据后计算CRC32
  4. 对比两个CRC32值，验证数据完整性

5.2 结束标记检测
----------------
标记：0xFF 0xFF 0xFF（3字节）

检测逻辑：
  - 在DMA接收过程中实时检测
  - 检测到标记后设置 transfer_complete = 1
  - 移除标记后再进行解压

5.3 错误修复机制
----------------
已知错误模式：
  1. </Datta> -> </Data>（多了一个't'）
  2. <Datta -> <Data（多了一个't'）
  3. /Data> -> </Data>（缺少'<'）
  4. valulue -> value（多了'lu'）
  5. 小数点后缺少0（108. -> 108.0）

修复方法：
  - 解压完成后扫描文件
  - 使用模式匹配查找错误
  - 就地修复（替换错误字节）

六、性能指标
================================================================================

6.1 内存占用
------------
- DMA硬件缓冲区：512字节
- 应用双缓冲区：8KB（2 × 4KB）
- 解压读取缓冲区：8KB
- 解压输出缓冲区：4KB
- 任务栈空间：8KB（BLE_KML_Task）
- 总计：约28KB

6.2 传输速度
------------
- 串口波特率：115200 bps
- 理论最大速度：14.4 KB/s
- 实际速度：约10-12 KB/s（考虑协议开销）

6.3 解压速度
------------
- 读取速度：受SD卡速度限制（约1-2 MB/s）
- 解压速度：约500 KB/s（CPU处理速度）
- 瓶颈：SD卡写入速度

6.4 文件大小支持
----------------
- 理论最大：受SD卡容量限制
- 实测：已成功处理数MB级别的KML文件
- 内存占用：与文件大小无关（流式处理）

七、任务调度与中断处理
================================================================================

7.1 中断与任务的分工
--------------------

系统采用"中断快速响应 + 任务慢速处理"的设计模式

硬件事件 → 中断处理(快) → 设置标志 → 任务处理(慢) → 完成
          (微秒级)                    (毫秒级)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【在中断中执行的任务】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
原则：快进快出，只做最必要的事情

1. DMA传输完成中断（HAL_UART_RxCpltCallback）
   执行内容：什么都不做！
   原因：DMA循环模式会自动重新开始，数据处理在任务中进行

2. DMA半传输中断（HAL_UART_RxHalfCpltCallback）
   执行内容：什么都不做！
   原因：保持代码简洁，任务中处理更灵活

3. 串口空闲中断（UART_IDLE_Callback）
   当前状态：未启用，使用定期轮询代替

中断的特点：
  ✓ 响应速度快（微秒级）
  ✓ 优先级高，可以打断任务
  ✓ 执行时间短（几微秒到几十微秒）
  ✓ 不能调用阻塞函数（如f_write、vTaskDelay）
  ✓ 不能执行耗时操作

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
【在任务中执行的任务】
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
原则：可以慢慢做，可以调用各种函数

1. 数据接收处理（Process_DMA_Data）
   执行位置：BLE_KML_Task任务
   执行频率：每10ms检查一次
   执行内容：检查DMA缓冲区、读取数据、检测结束标记、写入应用缓冲区
   为什么在任务中？需要逐字节处理，可能耗时较长

2. SD卡写入（f_write）
   执行位置：BLE_KML_Task任务
   执行频率：缓冲区满时触发
   执行内容：调用f_write写入SD卡、更新统计、重置缓冲区
   为什么在任务中？SD卡写入很慢（几十毫秒），FatFS函数不是中断安全的

3. 流式解压（decompression）
   执行位置：BLE_KML_Task任务
   执行频率：传输完成后触发一次
   执行内容：打开文件、分配内存、循环解压、错误修复、释放内存
   为什么在任务中？整个过程可能需要几秒钟，需要大量内存和文件操作

4. 调试输出（HAL_UART_Transmit）
   执行位置：BLE_KML_Task任务
   执行频率：需要时调用
   为什么在任务中？串口发送需要时间，不能在中断中阻塞
   注意：接收数据期间禁止发送！

任务的特点：
  ✓ 可以执行耗时操作
  ✓ 可以调用阻塞函数（f_write、vTaskDelay等）
  ✓ 可以分配大量内存
  ✓ 可以被中断打断
  ✓ 优先级低于中断

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
数据流转：中断与任务的配合
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
完整流程：
1. 串口接收数据（硬件）
2. DMA自动搬运到DMA缓冲区（硬件，无需CPU）
3. DMA中断触发（中断，但什么都不做）
4. BLE_KML_Task任务定期检查（任务，每10ms）
5. Process_DMA_Data处理数据（任务）
6. 应用缓冲区满时写入SD卡（任务）
7. 传输完成后解压（任务）

关键点：
  - 中断只负责硬件事件响应（实际上我们的中断什么都不做）
  - 所有数据处理都在任务中完成
  - 任务可以慢慢处理，不影响硬件接收

7.2 FreeRTOS任务配置
--------------------
任务名称：BLE_KML_Task
优先级：osPriorityNormal
栈大小：8KB（2048 × 4字节）

八、调试与监控
================================================================================
8.1 串口调试输出
----------------
注意：在数据接收期间，禁止通过同一串口发送调试信息！
原因：调试信息会混入数据流，导致数据损坏

调试信息输出时机：
  - 系统启动时
  - 文件打开/关闭时
  - 传输完成时
  - 解压开始/结束时
  - 错误发生时

8.2 统计信息
------------
接收阶段：
  - 总接收字节数
  - 写入SD卡次数
  - 缓冲区切换次数

解压阶段：
  - 压缩文件大小
  - 解压后文件大小
  - 坐标块数量（0xFE标记数量）
  - 总坐标点数
  - 错误修复次数

8.3 错误处理
------------
可能的错误：
  1. SD卡挂载失败 -> 进入死循环，等待重启
  2. 文件打开失败 -> 延时1秒后重试
  3. 写入失败 -> 打印错误码，继续尝试
  4. 内存分配失败 -> 打印错误，跳过解压
  5. CRC校验失败 -> 打印警告，但继续处理

九、使用说明
================================================================================
1. **准备**：SD卡FAT32格式化，烧录程序到STM32
2. **配置**：串口波特率115200，8N1
3. **测试**：发送压缩数据，以 `0xFF 0xFF 0xFF` 结束
4. **验证**：检查SD卡生成的文件
   - `0:/kml/compressed_kml.bin`（压缩数据）
   - `0:/kml/decompressed_kml.kml`（解压后的数据）

================================================================================
                              文档版本：V1.2
                              更新日期：2026-02-19
================================================================================
