/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * File Name          : freertos.c
 * Description        : Code for freertos applications
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

#include "ff.h"
#include "fatfs.h"
#include "GPS.h"
#include "gh_demo.h"
#include "testPage.h"
#include "APP.h"
#include "kml_parse_v2.h"
#include <string.h>
#include <stdio.h>
/* USER CODE END Includes */

// 动态生成CRC32表（与小程序端相同的算法）
static uint32_t crc_table[256];

// 初始化CRC32表
void init_crc_table(void) {
    for (uint32_t i = 0; i < 256; i++) {
        uint32_t crc = i;
        for (uint32_t j = 0; j < 8; j++) {
            crc = (crc >> 1) ^ ((crc & 1) ? 0xEDB88320 : 0);
        }
        crc_table[i] = crc;
    }
}

/**
 * 计算CRC32值（与小程序端一致）
 *
 * @param data 数据缓冲区
 * @param length 数据长度
 * @return CRC32值
 */
uint32_t calculate_crc32(const uint8_t* data, uint32_t length) {
    uint32_t crc = 0xFFFFFFFF;
    
    for (uint32_t i = 0; i < length; i++) {
        crc = (crc >> 8) ^ crc_table[(crc & 0xFF) ^ data[i]];
    }
    
    return crc ^ 0xFFFFFFFF;
}

/**
 * 验证CRC32值是否与小程序端一致
 *
 * @param data 数据缓冲区
 * @param length 数据长度
 * @param expected_crc 小程序端发送的CRC32值
 * @return 是否验证通过
 */
bool verify_crc32_with_expected(const uint8_t* data, uint32_t length, uint32_t expected_crc) {
    uint32_t calculated_crc = calculate_crc32(data, length);
    
    uint8_t verify_msg[150];
    sprintf((char*)verify_msg, "=== CRC32 Verification ===\r\nCalculated CRC: 0x%08lX\r\nExpected CRC: 0x%08lX\r\nMatch: %s\r\n", 
            calculated_crc, expected_crc, calculated_crc == expected_crc ? "YES" : "NO");
    HAL_UART_Transmit(&huart1, verify_msg, strlen((char*)verify_msg), 100);
    
    return calculated_crc == expected_crc;
}

/**
 * 处理接收到的数据并验证CRC32
 *
 * @param data 接收到的数据（包括结束符）
 * @param length 数据长度
 * @param expected_crc 小程序端发送的CRC32值
 * @return 是否验证通过
 */
bool verify_crc32(const uint8_t* data, uint32_t length, uint32_t expected_crc) {
    // 移除结束序列
    if (length >= 3 && data[length - 1] == 0xFF && data[length - 2] == 0xFF && data[length - 3] == 0xFF) {
        length -= 3;
    }
    
    // 计算CRC32
    uint32_t calculated_crc = calculate_crc32(data, length);
    
    // 验证CRC32
    return calculated_crc == expected_crc;
}

// 兼容旧的函数名
uint32_t calculateCRC32(uint8_t* data, uint32_t length) {
    return calculate_crc32(data, length);
}

// 测试CRC算法是否正确
void test_crc_algorithm(void) {
    // 测试数据："test data"
    uint8_t test_data[] = {'t', 'e', 's', 't', ' ', 'd', 'a', 't', 'a'};
    uint32_t crc = calculate_crc32(test_data, sizeof(test_data));
    
    uint8_t test_msg[100];
    sprintf((char*)test_msg, "=== CRC Algorithm Test ===\r\nTest data: \"test data\"\r\nCRC: 0x%08lX\r\n", crc);
    HAL_UART_Transmit(&huart1, test_msg, strlen((char*)test_msg), 100);
}

// 标签映射表（与小程序端相同）
static const char* tag_map[] = {
    NULL,                           // 0x80 未使用
    "<kml xmlns=\"http://www.opengis.net/kml/2.2\">",  // 0x81
    "</kml>",                       // 0x82
    "<Placemark>",                  // 0x83
    "</Placemark>",                 // 0x84
    "<name>",                       // 0x85
    "</name>",                      // 0x86
    "<description>",                // 0x87
    "</description>",               // 0x88
    "<Point>",                      // 0x89
    "</Point>",                     // 0x8A
    "<coordinates>",                // 0x8B
    "</coordinates>",               // 0x8C
    "<?xml version=\"1.0\" encoding=\"UTF-8\"?>",  // 0x8D
    "\r\n",                        // 0x8E
    "\n"                           // 0x8F
};

// 解压函数（基于坐标数据压缩算法）
// 与小程序端的压缩算法完全兼容
uint32_t decompressData(uint8_t* compressedData, uint32_t compressedSize, uint8_t* outputBuffer, uint32_t outputBufferSize) {
  if (compressedSize < 2 || outputBufferSize == 0) {
    return 0;
  }
  
  uint32_t inPos = 0;
  uint32_t outPos = 0;
  
  // 检查压缩标识
  if (compressedData[0] != 0x42 || compressedData[1] != 0x4C) {
    return 0; // 无效的压缩标识
  }
  
  // 跳过压缩标识
  inPos = 2;
  
  while (inPos < compressedSize && outPos < outputBufferSize) {
    uint8_t byte = compressedData[inPos++];
    
    if (byte == 0xfe) {
      // 处理坐标数据
      if (inPos + 2 > compressedSize) {
        return 0; // 数据长度不足
      }
      
      // 读取坐标数量（小端序）
      int coord_count = compressedData[inPos] | (compressedData[inPos + 1] << 8);
      inPos += 2;
      
      // 写入<coordinates>标签
      const char* start_tag = "<coordinates>";
      int start_tag_len = strlen(start_tag);
      if (outPos + start_tag_len > outputBufferSize) {
        return 0; // 解压缓冲区不足
      }
      memcpy(&outputBuffer[outPos], start_tag, start_tag_len);
      outPos += start_tag_len;
      
      // 处理每个坐标
      for (int i = 0; i < coord_count; i++) {
        if (inPos + 12 > compressedSize) {
          return 0; // 数据长度不足
        }
        
        // 读取坐标数据（小端序）
        int32_t lon_int = (int32_t)(compressedData[inPos] | (compressedData[inPos + 1] << 8) | (compressedData[inPos + 2] << 16) | (compressedData[inPos + 3] << 24));
        int32_t lat_int = (int32_t)(compressedData[inPos + 4] | (compressedData[inPos + 5] << 8) | (compressedData[inPos + 6] << 16) | (compressedData[inPos + 7] << 24));
        int32_t alt_int = (int32_t)(compressedData[inPos + 8] | (compressedData[inPos + 9] << 8) | (compressedData[inPos + 10] << 16) | (compressedData[inPos + 11] << 24));
        inPos += 12;
        
        // 转换回浮点数
        double lon = lon_int / 1000000.0;
        double lat = lat_int / 1000000.0;
        double alt = alt_int / 1000000.0;
        
        // 格式化坐标字符串
        char coord_str[64];
        int coord_str_len = snprintf(coord_str, sizeof(coord_str), "%.6f,%.6f,%.6f", lon, lat, alt);
        
        // 去除尾部多余的0，但至少保留一位小数
        char* dot_pos = strchr(coord_str, '.');
        if (dot_pos) {
          // 从末尾开始查找非零字符
          char* end_pos = coord_str + coord_str_len - 1;
          while (end_pos > dot_pos && *end_pos == '0') {
            end_pos--;
          }
          // 如果末尾是小数点，添加一个0
          if (end_pos == dot_pos) {
            end_pos++;
          }
          // 截断字符串
          end_pos++;
          *end_pos = ' '; // 添加空格分隔符
          coord_str_len = end_pos - coord_str + 1; // 包含空格
        }
        
        // 写入坐标数据
        if (outPos + coord_str_len > outputBufferSize) {
          return 0; // 解压缓冲区不足
        }
        memcpy(&outputBuffer[outPos], coord_str, coord_str_len);
        outPos += coord_str_len;
      }
      
      // 写入</coordinates>标签
      const char* end_tag = "</coordinates>";
      int end_tag_len = strlen(end_tag);
      if (outPos + end_tag_len > outputBufferSize) {
        return 0; // 解压缓冲区不足
      }
      memcpy(&outputBuffer[outPos], end_tag, end_tag_len);
      outPos += end_tag_len;
    } else if (byte < 0x80) {
      // 处理单字节UTF-8字符
      if (outPos >= outputBufferSize) {
        return 0; // 解压缓冲区不足
      }
      outputBuffer[outPos++] = byte;
    } else if (byte >= 0xc0 && byte < 0xe0) {
      // 处理双字节UTF-8字符
      if (inPos >= compressedSize) {
        return 0; // 数据长度不足
      }
      if (outPos + 2 > outputBufferSize) {
        return 0; // 解压缓冲区不足
      }
      outputBuffer[outPos++] = byte;
      outputBuffer[outPos++] = compressedData[inPos++];
    } else if (byte >= 0xe0 && byte < 0xf0) {
      // 处理三字节UTF-8字符
      if (inPos + 1 >= compressedSize) {
        return 0; // 数据长度不足
      }
      if (outPos + 3 > outputBufferSize) {
        return 0; // 解压缓冲区不足
      }
      outputBuffer[outPos++] = byte;
      outputBuffer[outPos++] = compressedData[inPos++];
      outputBuffer[outPos++] = compressedData[inPos++];
    } else if (byte >= 0xf0 && byte < 0xf8) {
      // 处理四字节UTF-8字符
      if (inPos + 2 >= compressedSize) {
        return 0; // 数据长度不足
      }
      if (outPos + 4 > outputBufferSize) {
        return 0; // 解压缓冲区不足
      }
      outputBuffer[outPos++] = byte;
      outputBuffer[outPos++] = compressedData[inPos++];
      outputBuffer[outPos++] = compressedData[inPos++];
      outputBuffer[outPos++] = compressedData[inPos++];
    } else if (byte >= 0x80 && byte < 0xc0) {
      // 处理UTF-8续字节
      if (outPos >= outputBufferSize) {
        return 0; // 解压缓冲区不足
      }
      outputBuffer[outPos++] = byte;
    } else {
      // 处理其他字节（错误的UTF-8字节等）
      if (outPos >= outputBufferSize) {
        return 0; // 解压缓冲区不足
      }
      outputBuffer[outPos++] = byte;
    }
  }
  
  return outPos; // 返回解压后的数据大小
}

/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* USER CODE BEGIN PV */
// 外部变量声明
extern StreamBufferHandle_t kml_stream_buf;
extern SemaphoreHandle_t kml_file_sem;
extern FIL SDFile;  // SDFile在fatfs.c中定义，这里声明为外部变量
extern FATFS SDFatFS;  // FatFS文件系统对象

// SD卡文件操作相关全局变量（声明为volatile确保中断中能正确读取）
volatile uint8_t sd_file_opened = 0;        // SD文件打开标志
volatile uint8_t kml_transfer_active = 0;   // KML传输激活标志

// 外部数据缓冲区变量声明（在usart.c中定义）
extern volatile uint8_t transfer_complete;
/* USER CODE END PV */

/* USER CODE BEGIN Variables */
GPS_Data GPS_data_share; //别的任务可以拿到的GPS数据

GPS_Data GPS_data;
uint8_t buf[GPS_UART_BUF_SIZE];
uint8_t gps_data_change;


/* USER CODE END Variables */
/* Definitions for TaskMain */
osThreadId_t TaskMainHandle;
const osThreadAttr_t TaskMain_attributes = {
  .name = "TaskMain",
  .stack_size = 4096 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for GPS_Task */
osThreadId_t GPS_TaskHandle;
const osThreadAttr_t GPS_Task_attributes = {
  .name = "GPS_Task",
  .stack_size = 1024 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for HR_Task */
osThreadId_t HR_TaskHandle;
const osThreadAttr_t HR_Task_attributes = {
  .name = "HR_Task",
  .stack_size = 256 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};
// ★新增：BLE KML任务的句柄和属性
osThreadId_t BLE_KML_TaskHandle;
const osThreadAttr_t BLE_KML_Task_attributes = {
  .name = "BLE_KML_Task",
  .stack_size = 2048 * 4,  // 足够处理文件操作的栈大小
  .priority = (osPriority_t) osPriorityNormal,
};

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN FunctionPrototypes */
// ★新增：声明BLE KML任务函数
void StartBLEKMLTask(void *argument);

/* USER CODE END FunctionPrototypes */

void StartTaskMain(void *argument);
void StartGPSTask(void *argument);
void StartTaskHR(void *argument);

void MX_FREERTOS_Init(void); /* (MISRA C 2004 rule 8.1) */

/* Hook prototypes */
void vApplicationTickHook(void);

/* USER CODE BEGIN 3 */
void vApplicationTickHook(void) {

	lv_tick_inc(1);

	/* This function will be called by each tick interrupt if
	 configUSE_TICK_HOOK is set to 1 in FreeRTOSConfig.h. User code can be
	 added here, but the tick hook is called from an interrupt context, so
	 code must not attempt to block, and only the interrupt safe FreeRTOS API
	 functions can be used (those that end in FromISR()). */
}
/* USER CODE END 3 */

/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */
	/* add semaphores, ... */
  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
	/* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  // /* creation of TaskMain */
  // TaskMainHandle = osThreadNew(StartTaskMain, NULL, &TaskMain_attributes);

  // /* creation of GPS_Task */
  // GPS_TaskHandle = osThreadNew(StartGPSTask, NULL, &GPS_Task_attributes);

  /* creation of HR_Task */
  HR_TaskHandle = osThreadNew(StartTaskHR, NULL, &HR_Task_attributes);

  // ★新增：创建BLE KML任务
  BLE_KML_TaskHandle = osThreadNew(StartBLEKMLTask, NULL, &BLE_KML_Task_attributes);

  /* USER CODE BEGIN RTOS_THREADS */
	/* add threads, ... */
  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
  /* USER CODE END RTOS_EVENTS */

}

/* USER CODE BEGIN Header_StartTaskMain */
/**
 * @brief  Function implementing the TaskMain thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_StartTaskMain */
void StartTaskMain(void *argument)
{
  /* USER CODE BEGIN StartTaskMain */
	lv_init();
	lv_port_init();
	/*
	lv_obj_t * img1 = lv_img_create(lv_scr_act());
	 const char *img_path = "S:/img/27.bin";
	lv_img_set_src(img1,img_path);

	 lv_obj_align(img1, LV_ALIGN_CENTER, 0, 0);
*/
//	lv_example_hr_display();
//	lvgl_st7789_test_page_create();
//	App_Init();

	const char* kml_file_path = "0:/track/HK100.kml";
	parse_kml_file(kml_file_path);
	filter_kml_lines(FILE_LINE_NAME, FILE_LINE_FILTERED_NAME);
	load_segment_to_global_buffer(FILE_LINE_NAME,2);
	App_Init();
	/* Infinite loop */
	for (;;) {
/*
		if (xSemaphoreTake(gps_mutex, pdMS_TO_TICKS(100)) == pdTRUE) {

			if(gps_data_change == 1){
				gps_data_change = 0;
				update_gps_display(lv_scr_act(), &GPS_data_share);
			}
			// 释放互斥锁（必须执行，否则其他任务会阻塞）
			xSemaphoreGive(gps_mutex);
		}
*/

		lv_timer_handler();
		vTaskDelay(pdMS_TO_TICKS(5));
	}
  /* USER CODE END StartTaskMain */
}

/* USER CODE BEGIN Header_StartGPSTask */
/**
 * @brief Function implementing the GPS_Task thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_StartGPSTask */
void StartGPSTask(void *argument)
{
  /* USER CODE BEGIN StartGPSTask */

	GPS_Init();
	gps_data_change = 0;
	/* Infinite loop */
	for (;;) {
		if (UART_ReadFrame(buf) == 1) {

			if (GPS_Parse((const char*) buf, &GPS_data) == 1) {
				if (xSemaphoreTake(gps_mutex, pdMS_TO_TICKS(500)) == pdTRUE) {
					// 安全写入全局结构体
					memcpy(&GPS_data_share, &GPS_data, sizeof(GPS_Data));
					//GPS_data_share = GPS_data;
					gps_data_change = 1;
					// 释放互斥锁（必须执行，否则其他任务会阻塞）
					xSemaphoreGive(gps_mutex);
				}
			}
		}
		vTaskDelay(pdMS_TO_TICKS(100));
	}

  /* USER CODE END StartGPSTask */
}

/* USER CODE BEGIN Header_StartTaskHR */
/**
 * @brief Function implementing the HR_Task thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_StartTaskHR */
void StartTaskHR(void *argument)
{
  /* USER CODE BEGIN StartTaskHR */
//	while(Gh3x2xDemoInit()!=GH3X2X_RET_OK);
	/* Infinite loop */
	for (;;) {
		HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
		vTaskDelay(pdMS_TO_TICKS(1000));
	}
  /* USER CODE END StartTaskHR */
}

// ★流式写入：BLE KML 任务 - 从串口接收数据并流式写入SD卡
/* USER CODE BEGIN Header_StartBLEKMLTask */
/**
 * @brief Function implementing the BLE_KML_Task thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_StartBLEKMLTask */
void StartBLEKMLTask(void *argument)
{
  /* USER CODE BEGIN StartBLEKMLTask */
  FRESULT res;
  // 定义缓冲区大小常量，用于限制每次写入的大小
  #define DECOMPRESS_BUFFER_SIZE 16384  // 16KB 缓冲区大小
  
  const char* test_file = "0:/test.txt";
  const char* kml_dir = "0:/kml";
  const char* compressed_file = "0:/kml/compressed_kml.bin";  // 存储压缩数据
  
  // 延时等待系统初始化完成（SD卡已在main中初始化）
  uint8_t wait_msg[] = "Waiting for SD init...\r\n";
  HAL_UART_Transmit(&huart1, wait_msg, strlen((char*)wait_msg), 100);
  vTaskDelay(pdMS_TO_TICKS(500));  // 缩短延迟时间

  // 发送启动消息
  uint8_t start_msg[] = "\r\n=== BLE KML Task Started ===\r\n";
  HAL_UART_Transmit(&huart1, start_msg, strlen((char*)start_msg), 100);
  
  // 初始化CRC32表
  init_crc_table();
  uint8_t crc_init_msg[] = "CRC32 table initialized\r\n";
  HAL_UART_Transmit(&huart1, crc_init_msg, strlen((char*)crc_init_msg), 100);
  
  // 测试CRC算法
  test_crc_algorithm();
  
  // 尝试挂载文件系统
  res = f_mount(&SDFatFS, "0:", 1);
  uint8_t mount_msg[50];
  sprintf((char*)mount_msg, "f_mount result: %d\r\n", res);
  HAL_UART_Transmit(&huart1, mount_msg, strlen((char*)mount_msg), 100);
  
  if (res != FR_OK) {
    uint8_t msg[] = "SD mount FAILED! Cannot continue.\r\n";
    HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
    // 进入死循环
    for(;;) { vTaskDelay(pdMS_TO_TICKS(1000)); }
  }
  
  uint8_t msg1[] = "SD mounted OK\r\n";
  HAL_UART_Transmit(&huart1, msg1, strlen((char*)msg1), 100);

  // === 测试1：读取根目录下的test.txt文件 ===
  uint8_t test_msg[] = "\r\n=== Test 1: Read test.txt ===\r\n";
  HAL_UART_Transmit(&huart1, test_msg, strlen((char*)test_msg), 100);
  
  FIL test_fil;
  res = f_open(&test_fil, test_file, FA_READ);
  uint8_t open_msg[50];
  sprintf((char*)open_msg, "f_open(test.txt) result: %d\r\n", res);
  HAL_UART_Transmit(&huart1, open_msg, strlen((char*)open_msg), 100);
  
  if (res == FR_OK) {
    uint8_t read_buf[100];
    UINT bytes_read;
    res = f_read(&test_fil, read_buf, sizeof(read_buf)-1, &bytes_read);
    f_close(&test_fil);
    
    if (res == FR_OK && bytes_read > 0) {
      read_buf[bytes_read] = '\0';  // 添加字符串结束符
      uint8_t msg[150];
      sprintf((char*)msg, "Read %d bytes: %s\r\n", bytes_read, read_buf);
      HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
    } else {
      uint8_t msg[] = "Read failed or empty file\r\n";
      HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
    }
  } else {
    uint8_t msg[] = "test.txt not found or cannot open\r\n";
    HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
  }

  // === 测试2：列出根目录文件 ===
  uint8_t test2_msg[] = "\r\n=== Test 2: List root directory ===\r\n";
  HAL_UART_Transmit(&huart1, test2_msg, strlen((char*)test2_msg), 100);
  
  DIR dir;
  FILINFO fno;
  res = f_opendir(&dir, "0:/");
  if (res == FR_OK) {
    uint8_t msg[] = "Root directory contents:\r\n";
    HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
    
    for (int i = 0; i < 10; i++) {  // 最多列出10个文件
      res = f_readdir(&dir, &fno);
      if (res != FR_OK || fno.fname[0] == 0) break;
      
      uint8_t file_msg[100];
      sprintf((char*)file_msg, "  %s (%lu bytes)\r\n", fno.fname, fno.fsize);
      HAL_UART_Transmit(&huart1, file_msg, strlen((char*)file_msg), 100);
    }
    f_closedir(&dir);
  } else {
    uint8_t msg[50];
    sprintf((char*)msg, "Cannot open root dir: %d\r\n", res);
    HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
  }

  // === 测试3：创建目录并写入文件 ===
  uint8_t test3_msg[] = "\r\n=== Test 3: Create directory and file ===\r\n";
  HAL_UART_Transmit(&huart1, test3_msg, strlen((char*)test3_msg), 100);
  
  // 检查文件系统类型
  uint8_t fs_type_msg[100];
  sprintf((char*)fs_type_msg, "File system type: %s\r\n", SDFatFS.fs_type == FS_FAT12 ? "FAT12" : 
          SDFatFS.fs_type == FS_FAT16 ? "FAT16" : 
          SDFatFS.fs_type == FS_FAT32 ? "FAT32" : "Unknown");
  HAL_UART_Transmit(&huart1, fs_type_msg, strlen((char*)fs_type_msg), 100);
  
  // 创建kml目录
  res = f_mkdir(kml_dir);
  uint8_t mkdir_msg[100];
  sprintf((char*)mkdir_msg, "f_mkdir(%s) result: %d\r\n", kml_dir, res);
  HAL_UART_Transmit(&huart1, mkdir_msg, strlen((char*)mkdir_msg), 100);
  
  if (res == FR_OK || res == FR_EXIST) {
    uint8_t msg[] = "Directory OK\r\n";
    HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
    
    // 列出kml目录内容
    uint8_t list_kml_msg[] = "kml directory contents:\r\n";
    HAL_UART_Transmit(&huart1, list_kml_msg, strlen((char*)list_kml_msg), 100);
    
    DIR kml_dir_obj;
    FILINFO kml_fno;
    res = f_opendir(&kml_dir_obj, kml_dir);
    if (res == FR_OK) {
      for (int i = 0; i < 10; i++) {
        res = f_readdir(&kml_dir_obj, &kml_fno);
        if (res != FR_OK || kml_fno.fname[0] == 0) break;
        
        uint8_t kml_file_msg[100];
        sprintf((char*)kml_file_msg, "  %s (%lu bytes)\r\n", kml_fno.fname, kml_fno.fsize);
        HAL_UART_Transmit(&huart1, kml_file_msg, strlen((char*)kml_file_msg), 100);
      }
      f_closedir(&kml_dir_obj);
    } else {
      uint8_t msg[50];
      sprintf((char*)msg, "Cannot open kml dir: %d\r\n", res);
      HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
    }
  }

  // 主循环
  for (;;) {
    // 检查是否需要打开文件
    if (!sd_file_opened && !kml_transfer_active) {
      // 重置缓冲区，确保开始接收新文件时缓冲区为空
      extern volatile uint8_t buffer_full[2];
      extern volatile uint32_t buffer_index[2];
      for (int i = 0; i < 2; i++) {
        buffer_full[i] = 0;
        buffer_index[i] = 0;
      }
      transfer_complete = 0;
      
      // 打开压缩文件准备接收数据，使用FA_CREATE_ALWAYS | FA_WRITE模式，确保每次都创建新文件
      uint8_t open_msg2[150];
      sprintf((char*)open_msg2, "Opening %s for compressed data reception...\r\n", compressed_file);
      HAL_UART_Transmit(&huart1, open_msg2, strlen((char*)open_msg2), 100);
      
      res = f_open(&SDFile, compressed_file, FA_CREATE_ALWAYS | FA_WRITE);
      uint8_t open_result_msg[100];
      sprintf((char*)open_result_msg, "f_open result: %d\r\n", res);
      HAL_UART_Transmit(&huart1, open_result_msg, strlen((char*)open_result_msg), 100);
      
      if (res == FR_OK) {
        sd_file_opened = 1;
        kml_transfer_active = 1;
        
        uint8_t msg2[150];
        sprintf((char*)msg2, "\r\n=== Ready to receive KML file ===\r\nFile: %s\r\nsd_file_opened=%d, kml_transfer_active=%d\r\n", 
                compressed_file, sd_file_opened, kml_transfer_active);
        HAL_UART_Transmit(&huart1, msg2, strlen((char*)msg2), 100);
        uint8_t msg3[] = "Waiting for KML file data...\r\nEnd with 0xFF 0xFF 0xFF to complete transfer\r\n\r\n";
        HAL_UART_Transmit(&huart1, msg3, strlen((char*)msg3), 100);
        
        // 立即打印缓冲区状态
        uint8_t buf_status[100];
        sprintf((char*)buf_status, "Initial buffer status: buf0_full=%d, buf1_full=%d\r\n", 
                buffer_full[0], buffer_full[1]);
        HAL_UART_Transmit(&huart1, buf_status, strlen((char*)buf_status), 100);
      } else {
        uint8_t msg[] = "Cannot create file for compressed data reception\r\n";
        HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
        vTaskDelay(pdMS_TO_TICKS(1000)); // 延迟后重试
      }
    }
    
    // 双缓冲区相关变量
    extern volatile uint8_t buffers[2][16384];  // 更新为16KB
    extern volatile uint32_t buffer_index[2];
    extern volatile uint8_t buffer_full[2];
    extern volatile uint8_t transfer_complete;
    
    // 移除心跳监控（用户要求）
    
    // 获取当前时间
    uint32_t now = HAL_GetTick();
    
    // 添加任务心跳，确认主任务在运行
    static uint32_t task_heartbeat_tick = 0;
    if(sd_file_opened && kml_transfer_active && (now - task_heartbeat_tick) > 3000) {
      uint8_t task_msg[100];
      sprintf((char*)task_msg, "TASK: Running, buf0=%d/%ld, buf1=%d/%ld\r\n", 
              buffer_full[0], buffer_index[0], buffer_full[1], buffer_index[1]);
      HAL_UART_Transmit(&huart1, task_msg, strlen((char*)task_msg), 50);
      task_heartbeat_tick = now;
    }
    
    // 检查并处理满的缓冲区
    static uint32_t total_written = 0;
    static uint32_t last_print_index = 0;
    static uint32_t write_count = 0;
    static uint32_t last_activity_tick = 0;
    
    // 禁用看门狗（临时）- SD卡写入太慢
    // 看门狗：检测是否长时间没有活动
    // uint32_t current_tick = HAL_GetTick();
    // if(sd_file_opened && kml_transfer_active) {
    //   if(last_activity_tick > 0 && (current_tick - last_activity_tick) > 5000) {
    //     // 超过5秒没有活动，可能卡死了
    //     uint8_t timeout_msg[80];
    //     sprintf((char*)timeout_msg, "TIMEOUT! No activity for 5s. Resetting...\r\n");
    //     HAL_UART_Transmit(&huart1, timeout_msg, strlen((char*)timeout_msg), 50);
    //     
    //     // 强制关闭文件并重置状态
    //     f_sync(&SDFile);
    //     f_close(&SDFile);
    //     sd_file_opened = 0;
    //     kml_transfer_active = 0;
    //     
    //     // 重置缓冲区
    //     for (int i = 0; i < 2; i++) {
    //       buffer_full[i] = 0;
    //       buffer_index[i] = 0;
    //     }
    //     transfer_complete = 0;
    //     total_written = 0;
    //     last_print_index = 0;
    //     write_count = 0;
    //     last_activity_tick = 0;
    //     continue;
    //   }
    // }
    
    for (int i = 0; i < 2; i++) {
      if (buffer_full[i] && sd_file_opened) {
        // 打印调试信息：检测到满缓冲区
        uint8_t debug_msg[80];
        sprintf((char*)debug_msg, "DEBUG: Buffer %d full, index=%ld\r\n", i, buffer_index[i]);
        HAL_UART_Transmit(&huart1, debug_msg, strlen((char*)debug_msg), 50);
        
        // 缓冲区满，写入SD卡
        uint32_t bytes_to_write = buffer_index[i];
        if (bytes_to_write > 0) {
          write_count++;
          // last_activity_tick = current_tick;  // 更新活动时间（已禁用看门狗）
          
          UINT bytes_written;
          
          // 记录写入开始时间
          uint32_t start_tick = HAL_GetTick();
          FRESULT res = f_write(&SDFile, (uint8_t*)buffers[i], bytes_to_write, &bytes_written);
          
          // 不要每次都同步，太慢了！只在最后同步
          // if(res == FR_OK) {
          //   f_sync(&SDFile);
          // }
          
          uint32_t write_time = HAL_GetTick() - start_tick;
          
          if(res == FR_OK && bytes_written == bytes_to_write) {
            total_written += bytes_written;
            
            // 如果写入时间过长，打印警告
            if(write_time > 100) {
              uint8_t warn_msg[80];
              sprintf((char*)warn_msg, "SLOW WRITE! %ld ms for %ld bytes\r\n", write_time, bytes_to_write);
              HAL_UART_Transmit(&huart1, warn_msg, strlen((char*)warn_msg), 50);
            }
            
            // 定期打印写入状态
            if(total_written - last_print_index > 5000) {  // 每5KB打印一次
              uint8_t write_msg[60];
              sprintf((char*)write_msg, "Write: %ld bytes (%ld writes)\r\n", total_written, write_count);
              HAL_UART_Transmit(&huart1, write_msg, strlen((char*)write_msg), 50);
              last_print_index = total_written;
            }
            // 重置缓冲区状态
            buffer_full[i] = 0;
            buffer_index[i] = 0;
          } else {
            // 写入失败或不完整，打印详细错误信息
            uint8_t err_msg[80];
            sprintf((char*)err_msg, "Write error: res=%d, wrote=%ld/%ld, time=%ld ms\r\n", 
                    res, bytes_written, bytes_to_write, write_time);
            HAL_UART_Transmit(&huart1, err_msg, strlen((char*)err_msg), 50);
            // 即使失败也要重置缓冲区，避免死锁
            buffer_full[i] = 0;
            buffer_index[i] = 0;
          }
        }
      }
    }
    
    // 检查传输是否完成
    if(transfer_complete && sd_file_opened){
      uint8_t complete_msg[] = "Transfer complete flag detected!\r\n";
      HAL_UART_Transmit(&huart1, complete_msg, strlen((char*)complete_msg), 50);
      
      // 确保所有满的缓冲区都写入了
      for (int i = 0; i < 2; i++) {
        if (buffer_full[i] || buffer_index[i] > 0) {
          uint32_t bytes_to_write = buffer_index[i];
          if (bytes_to_write > 0) {
            uint8_t final_buf_msg[80];
            sprintf((char*)final_buf_msg, "Writing final buffer %d: %ld bytes\r\n", i, bytes_to_write);
            HAL_UART_Transmit(&huart1, final_buf_msg, strlen((char*)final_buf_msg), 50);
            
            UINT bytes_written;
            FRESULT res = f_write(&SDFile, (uint8_t*)buffers[i], bytes_to_write, &bytes_written);
            
            if(res == FR_OK && bytes_written == bytes_to_write) {
              // 立即同步
              f_sync(&SDFile);
              total_written += bytes_written;
              
              uint8_t success_msg[80];
              sprintf((char*)success_msg, "Final buffer %d written: %ld bytes\r\n", i, bytes_written);
              HAL_UART_Transmit(&huart1, success_msg, strlen((char*)success_msg), 50);
              
              // 重置缓冲区状态
              buffer_full[i] = 0;
              buffer_index[i] = 0;
            } else {
              // 最终写入失败
              uint8_t final_err_msg[100];
              sprintf((char*)final_err_msg, "Final Write error: res=%d, wrote=%ld/%ld\r\n", 
                      res, bytes_written, bytes_to_write);
              HAL_UART_Transmit(&huart1, final_err_msg, strlen((char*)final_err_msg), 100);
              break;
            }
          }
        }
      }
      
      // 打印最终写入状态（在重置前保存）
      uint32_t final_total_written = total_written;
      uint8_t final_write_msg[100];
      sprintf((char*)final_write_msg, "Final Write: Total %ld bytes written\r\n", final_total_written);
      HAL_UART_Transmit(&huart1, final_write_msg, strlen((char*)final_write_msg), 100);
      
      // 最后一次性同步所有数据到SD卡
      uint8_t sync_msg[] = "Syncing to SD card...\r\n";
      HAL_UART_Transmit(&huart1, sync_msg, strlen((char*)sync_msg), 100);
      
      uint32_t sync_start = HAL_GetTick();
      f_sync(&SDFile);
      uint32_t sync_time = HAL_GetTick() - sync_start;
      
      uint8_t sync_done_msg[80];
      sprintf((char*)sync_done_msg, "Sync complete! Time: %ld ms\r\n", sync_time);
      HAL_UART_Transmit(&huart1, sync_done_msg, strlen((char*)sync_done_msg), 100);
      
      // 关闭压缩文件（在重置前）
      f_close(&SDFile);
      sd_file_opened = 0;
      
      // 重置总写入计数（在关闭文件后）
      total_written = 0;
      last_print_index = 0;
      write_count = 0;
      
      // 定义文件路径变量，扩大作用域
      char decompressed_file[] = "0:/kml/decompressed_kml.kml";
      
      // 打印压缩文件传输完成信息
      uint8_t msg[120];
      sprintf((char*)msg, "=== Compressed File Transfer Complete ===\r\nFile: %s\r\nTotal Written: %ld bytes\r\n", 
              compressed_file, final_total_written);
      HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
      
      // 完全流式处理：边读边解压，不加载整个文件到内存
      FIL read_file;
      res = f_open(&read_file, compressed_file, FA_OPEN_EXISTING | FA_READ);
      if (res == FR_OK) {
        // 获取文件大小
        uint32_t file_size = f_size(&read_file);
        
        // 打印实际接收到的数据大小
        uint8_t size_msg[100];
        sprintf((char*)size_msg, "=== Stream Decompression Start ===\r\nCompressed file size: %ld bytes\r\n", file_size);
        HAL_UART_Transmit(&huart1, size_msg, strlen((char*)size_msg), 100);
        
        // 分配读取缓冲区（8KB）和写入缓冲区（16KB）
        #define READ_CHUNK_SIZE 8192
        #define WRITE_CHUNK_SIZE 16384
        
        uint8_t* read_buffer = (uint8_t*)malloc(READ_CHUNK_SIZE);
        uint8_t* write_buffer = (uint8_t*)malloc(WRITE_CHUNK_SIZE);
        
        if (read_buffer && write_buffer) {
          uint8_t mem_alloc_msg[100];
          sprintf((char*)mem_alloc_msg, "Memory allocated: read=%d bytes, write=%d bytes\r\n", 
                  READ_CHUNK_SIZE, WRITE_CHUNK_SIZE);
          HAL_UART_Transmit(&huart1, mem_alloc_msg, strlen((char*)mem_alloc_msg), 100);
          
          // 打开解压输出文件
          FIL decompressed_fd;
          res = f_open(&decompressed_fd, decompressed_file, FA_CREATE_ALWAYS | FA_WRITE);
          
          if (res == FR_OK) {
            uint32_t total_read = 0;
            uint32_t decompressed_size = 0;
            uint32_t write_buffer_pos = 0;
            
            // 读取并验证压缩标识
            UINT bytes_read;
            res = f_read(&read_file, read_buffer, 2, &bytes_read);
            if (res == FR_OK && bytes_read == 2 && read_buffer[0] == 0x42 && read_buffer[1] == 0x4C) {
              total_read = 2;
              uint8_t header_msg[] = "Valid compression header found (BL)\r\n";
              HAL_UART_Transmit(&huart1, header_msg, strlen((char*)header_msg), 100);
              
              // 流式解压循环
              uint32_t read_pos = 0;
              uint32_t read_available = 0;
              
              while (total_read < file_size) {
              // 移除结束序列（0xFF 0xFF 0xFF），如果存在
              uint32_t data_length = total_read;
              if (data_length >= 3 && full_buffer[data_length - 1] == 0xFF && full_buffer[data_length - 2] == 0xFF && full_buffer[data_length - 3] == 0xFF) {
                data_length -= 3;
                uint8_t end_marker_msg[50];
                sprintf((char*)end_marker_msg, "End sequence 0xFF 0xFF 0xFF found and removed.\r\n");
                HAL_UART_Transmit(&huart1, end_marker_msg, strlen((char*)end_marker_msg), 100);
              }
            
              // 计算压缩数据的CRC（移除结束符后）
              uint32_t crc_before = calculateCRC32(full_buffer, data_length);
              uint8_t crc_before_msg[100];
              sprintf((char*)crc_before_msg, "=== CRC32 Check ===\r\nCRC of received data: 0x%08lX\r\nData length: %ld bytes\r\n", crc_before, data_length);
              HAL_UART_Transmit(&huart1, crc_before_msg, strlen((char*)crc_before_msg), 100);
              
              // 验证CRC是否与小程序端一致
              verify_crc32_with_expected(full_buffer, data_length, 0x155E64C5);
            
              // 直接保存原始压缩数据为bin文件（不包含结束符）
              FIL bin_fd;
              char bin_file[] = "0:/kml/compressed_kml.bin";
              res = f_open(&bin_fd, bin_file, FA_CREATE_ALWAYS | FA_WRITE);
              if(res == FR_OK) {
                UINT bytes_written;
                res = f_write(&bin_fd, full_buffer, data_length, &bytes_written);
                if(res == FR_OK) {
                  f_sync(&bin_fd);
                  f_close(&bin_fd);
                  
                  uint8_t bin_msg[100];
                  sprintf((char*)bin_msg, "=== Bin File Created ===\r\nFile: %s\r\nSize: %ld bytes\r\n", 
                          bin_file, data_length);
                  HAL_UART_Transmit(&huart1, bin_msg, strlen((char*)bin_msg), 100);
                } else {
                  uint8_t bin_err_msg[100];
                  sprintf((char*)bin_err_msg, "Failed to write bin file: %d\r\n", res);
                  HAL_UART_Transmit(&huart1, bin_err_msg, strlen((char*)bin_err_msg), 100);
                }
              } else {
                uint8_t bin_err_msg[100];
                sprintf((char*)bin_err_msg, "Failed to open bin file: %d\r\n", res);
                HAL_UART_Transmit(&huart1, bin_err_msg, strlen((char*)bin_err_msg), 100);
              }
            
              // 流式解压到文件
              uint32_t decompressed_size = 0;
              
              // 打开解压后的文件准备写入
              FIL decompressed_fd;
              res = f_open(&decompressed_fd, decompressed_file, FA_CREATE_ALWAYS | FA_WRITE);
              if(res == FR_OK) {
                uint8_t decompress_start_msg[100];
                sprintf((char*)decompress_start_msg, "=== Starting Stream Decompression ===\r\nCompressed size: %ld bytes\r\n", 
                        data_length);
                HAL_UART_Transmit(&huart1, decompress_start_msg, strlen((char*)decompress_start_msg), 100);
                
                // 使用较小的缓冲区进行流式解压（16KB）
                #define STREAM_DECOMPRESS_BUFFER_SIZE 16384
                uint8_t* decompress_buffer = (uint8_t*)malloc(STREAM_DECOMPRESS_BUFFER_SIZE);
                
                if (decompress_buffer) {
                  uint8_t mem_alloc_msg2[100];
                  sprintf((char*)mem_alloc_msg2, "Allocated %d bytes for stream decompression buffer\r\n", STREAM_DECOMPRESS_BUFFER_SIZE);
                  HAL_UART_Transmit(&huart1, mem_alloc_msg2, strlen((char*)mem_alloc_msg2), 100);
                  
                  // 调用解压函数，直接写入文件
                  uint32_t inPos = 0;
                  
                  // 检查压缩标识
                  if (data_length >= 2 && full_buffer[0] == 0x42 && full_buffer[1] == 0x4C) {
                    inPos = 2; // 跳过压缩标识
                    
                    uint8_t* write_buffer = decompress_buffer;
                    uint32_t write_buffer_pos = 0;
                  
                    // 逐字节解压
                    while (inPos < data_length) {
                      uint8_t byte = full_buffer[inPos++];
                    
                      if (byte == 0xfe) {
                        // 处理坐标数据
                        if (inPos + 2 > data_length) break;
                        
                        // 读取坐标数量（小端序）
                        int coord_count = full_buffer[inPos] | (full_buffer[inPos + 1] << 8);
                        inPos += 2;
                      
                      // 写入<coordinates>标签
                      const char* start_tag = "<coordinates>";
                      int start_tag_len = strlen(start_tag);
                      
                      // 检查缓冲区空间
                      if (write_buffer_pos + start_tag_len > STREAM_DECOMPRESS_BUFFER_SIZE) {
                        // 写入文件
                        UINT bw;
                        f_write(&decompressed_fd, write_buffer, write_buffer_pos, &bw);
                        decompressed_size += bw;
                        write_buffer_pos = 0;
                      }
                      
                      memcpy(&write_buffer[write_buffer_pos], start_tag, start_tag_len);
                      write_buffer_pos += start_tag_len;
                      
                        // 处理每个坐标
                        for (int i = 0; i < coord_count; i++) {
                          if (inPos + 12 > data_length) break;
                          
                          // 读取坐标数据（小端序）
                          int32_t lon_int = (int32_t)(full_buffer[inPos] | (full_buffer[inPos + 1] << 8) | (full_buffer[inPos + 2] << 16) | (full_buffer[inPos + 3] << 24));
                          int32_t lat_int = (int32_t)(full_buffer[inPos + 4] | (full_buffer[inPos + 5] << 8) | (full_buffer[inPos + 6] << 16) | (full_buffer[inPos + 7] << 24));
                          int32_t alt_int = (int32_t)(full_buffer[inPos + 8] | (full_buffer[inPos + 9] << 8) | (full_buffer[inPos + 10] << 16) | (full_buffer[inPos + 11] << 24));
                          inPos += 12;
                        
                          // 转换回浮点数
                          double lon = lon_int / 1000000.0;
                          double lat = lat_int / 1000000.0;
                          double alt = alt_int / 1000000.0;
                          
                          // 格式化坐标字符串
                          char coord_str[64];
                          int coord_str_len = snprintf(coord_str, sizeof(coord_str), "%.6f,%.6f,%.6f", lon, lat, alt);
                          
                          // 去除尾部多余的0
                          char* dot_pos = strchr(coord_str, '.');
                          if (dot_pos) {
                            char* end_pos = coord_str + coord_str_len - 1;
                            while (end_pos > dot_pos && *end_pos == '0') {
                              end_pos--;
                            }
                            if (end_pos == dot_pos) {
                              end_pos++;
                            }
                            end_pos++;
                            *end_pos = ' ';
                            coord_str_len = end_pos - coord_str + 1;
                          }
                          
                          // 检查缓冲区空间
                          if (write_buffer_pos + coord_str_len > STREAM_DECOMPRESS_BUFFER_SIZE) {
                            // 写入文件
                            UINT bw;
                            f_write(&decompressed_fd, write_buffer, write_buffer_pos, &bw);
                            decompressed_size += bw;
                            write_buffer_pos = 0;
                          }
                          
                          memcpy(&write_buffer[write_buffer_pos], coord_str, coord_str_len);
                          write_buffer_pos += coord_str_len;
                        }
                      
                        // 写入</coordinates>标签
                        const char* end_tag = "</coordinates>";
                        int end_tag_len = strlen(end_tag);
                        
                        // 检查缓冲区空间
                        if (write_buffer_pos + end_tag_len > STREAM_DECOMPRESS_BUFFER_SIZE) {
                          // 写入文件
                          UINT bw;
                          f_write(&decompressed_fd, write_buffer, write_buffer_pos, &bw);
                          decompressed_size += bw;
                          write_buffer_pos = 0;
                        }
                        
                        memcpy(&write_buffer[write_buffer_pos], end_tag, end_tag_len);
                        write_buffer_pos += end_tag_len;
                      } else if (byte < 0x80) {
                        // 单字节UTF-8
                        if (write_buffer_pos >= STREAM_DECOMPRESS_BUFFER_SIZE) {
                          UINT bw;
                          f_write(&decompressed_fd, write_buffer, write_buffer_pos, &bw);
                          decompressed_size += bw;
                          write_buffer_pos = 0;
                        }
                        write_buffer[write_buffer_pos++] = byte;
                      } else if (byte >= 0xc0 && byte < 0xe0) {
                        // 双字节UTF-8
                        if (inPos >= data_length) break;
                        if (write_buffer_pos + 2 > STREAM_DECOMPRESS_BUFFER_SIZE) {
                          UINT bw;
                          f_write(&decompressed_fd, write_buffer, write_buffer_pos, &bw);
                          decompressed_size += bw;
                          write_buffer_pos = 0;
                        }
                        write_buffer[write_buffer_pos++] = byte;
                        write_buffer[write_buffer_pos++] = full_buffer[inPos++];
                      } else if (byte >= 0xe0 && byte < 0xf0) {
                        // 三字节UTF-8
                        if (inPos + 1 >= data_length) break;
                        if (write_buffer_pos + 3 > STREAM_DECOMPRESS_BUFFER_SIZE) {
                          UINT bw;
                          f_write(&decompressed_fd, write_buffer, write_buffer_pos, &bw);
                          decompressed_size += bw;
                          write_buffer_pos = 0;
                        }
                        write_buffer[write_buffer_pos++] = byte;
                        write_buffer[write_buffer_pos++] = full_buffer[inPos++];
                        write_buffer[write_buffer_pos++] = full_buffer[inPos++];
                      } else if (byte >= 0xf0 && byte < 0xf8) {
                        // 四字节UTF-8
                        if (inPos + 2 >= data_length) break;
                        if (write_buffer_pos + 4 > STREAM_DECOMPRESS_BUFFER_SIZE) {
                          UINT bw;
                          f_write(&decompressed_fd, write_buffer, write_buffer_pos, &bw);
                          decompressed_size += bw;
                          write_buffer_pos = 0;
                        }
                        write_buffer[write_buffer_pos++] = byte;
                        write_buffer[write_buffer_pos++] = full_buffer[inPos++];
                        write_buffer[write_buffer_pos++] = full_buffer[inPos++];
                        write_buffer[write_buffer_pos++] = full_buffer[inPos++];
                      } else {
                        // 其他字节
                        if (write_buffer_pos >= STREAM_DECOMPRESS_BUFFER_SIZE) {
                          UINT bw;
                          f_write(&decompressed_fd, write_buffer, write_buffer_pos, &bw);
                          decompressed_size += bw;
                          write_buffer_pos = 0;
                        }
                        write_buffer[write_buffer_pos++] = byte;
                      }
                    }
                  
                    // 写入剩余数据
                    if (write_buffer_pos > 0) {
                      UINT bw;
                      f_write(&decompressed_fd, write_buffer, write_buffer_pos, &bw);
                      decompressed_size += bw;
                    }
                    
                    uint8_t decompressed_msg[100];
                    sprintf((char*)decompressed_msg, "=== Decompressed File Created ===\r\nFile: %s\r\nSize: %ld bytes\r\n", 
                            decompressed_file, decompressed_size);
                    HAL_UART_Transmit(&huart1, decompressed_msg, strlen((char*)decompressed_msg), 100);
                  } else {
                    uint8_t decompress_err_msg[150];
                    sprintf((char*)decompress_err_msg, "Decompression failed! Invalid header\r\nFirst 2 bytes: 0x%02x 0x%02x\r\n", 
                            full_buffer[0], full_buffer[1]);
                    HAL_UART_Transmit(&huart1, decompress_err_msg, strlen((char*)decompress_err_msg), 100);
                  }
                  
                  free(decompress_buffer);
                  uint8_t mem_free_msg2[] = "Freed decompression buffer\r\n";
                  HAL_UART_Transmit(&huart1, mem_free_msg2, strlen((char*)mem_free_msg2), 100);
                } else {
                  uint8_t mem_err_msg[] = "Failed to allocate memory for stream decompression\r\n";
                  HAL_UART_Transmit(&huart1, mem_err_msg, strlen((char*)mem_err_msg), 100);
                }
                
                // 同步并关闭解压文件
                f_sync(&decompressed_fd);
                f_close(&decompressed_fd);
              } else {
                uint8_t decompressed_err_msg[100];
                sprintf((char*)decompressed_err_msg, "Failed to open decompressed file: %d\r\n", res);
                HAL_UART_Transmit(&huart1, decompressed_err_msg, strlen((char*)decompressed_err_msg), 100);
              }
              
              uint8_t success_msg[] = "KML file received and processed successfully!\r\n";
              HAL_UART_Transmit(&huart1, success_msg, strlen((char*)success_msg), 100);
            } else {
              uint8_t read_err_msg[100];
              sprintf((char*)read_err_msg, "Failed to read all data: read %ld/%ld bytes\r\n", total_read, file_size);
              HAL_UART_Transmit(&huart1, read_err_msg, strlen((char*)read_err_msg), 100);
            }
            
            free(full_buffer);
            uint8_t mem_free_msg[] = "Freed full buffer\r\n";
            HAL_UART_Transmit(&huart1, mem_free_msg, strlen((char*)mem_free_msg), 100);
          } else {
            uint8_t mem_err_msg[100];
            sprintf((char*)mem_err_msg, "Failed to allocate %ld bytes for full buffer\r\n", file_size);
            HAL_UART_Transmit(&huart1, mem_err_msg, strlen((char*)mem_err_msg), 100);
          }
          
          free(file_buffer);
          uint8_t mem_free_msg[] = "Freed read buffer\r\n";
          HAL_UART_Transmit(&huart1, mem_free_msg, strlen((char*)mem_free_msg), 100);
        } else {
          uint8_t mem_err_msg[] = "Failed to allocate memory for read buffer\r\n";
          HAL_UART_Transmit(&huart1, mem_err_msg, strlen((char*)mem_err_msg), 100);
        }
        
        f_close(&read_file);
      } else {
        uint8_t open_err_msg[100];
        sprintf((char*)open_err_msg, "Failed to open compressed file: %d\r\n", res);
        HAL_UART_Transmit(&huart1, open_err_msg, strlen((char*)open_err_msg), 100);
      }
      
      // 重置缓冲区状态
      for (int i = 0; i < 2; i++) {
        buffer_full[i] = 0;
        buffer_index[i] = 0;
      }
      transfer_complete = 0;
      
      vTaskDelay(pdMS_TO_TICKS(1000));
      
      // 不重新打开压缩文件，保留之前的文件供后续检查
      // 这样用户可以查看压缩文件的内容和大小
      sd_file_opened = 0;
      uint8_t ready_msg[150];
      sprintf((char*)ready_msg, "Ready for next transfer\r\nPrevious compressed file saved as: %s\r\n", compressed_file);
      HAL_UART_Transmit(&huart1, ready_msg, strlen((char*)ready_msg), 100);
      kml_transfer_active = 1;
      
      // 验证文件是否创建成功并读取内容
      uint8_t verify_msg[] = "\r\n=== Verifying File Creation ===\r\n";
      HAL_UART_Transmit(&huart1, verify_msg, strlen((char*)verify_msg), 100);
      
      // 列出kml目录内容，确认文件存在
      uint8_t list_msg[] = "kml directory contents after transfer:\r\n";
      HAL_UART_Transmit(&huart1, list_msg, strlen((char*)list_msg), 100);
      
      DIR dir2;
      FILINFO fno2;
      res = f_opendir(&dir2, kml_dir);
      if (res == FR_OK) {
        for (int i = 0; i < 10; i++) {
          res = f_readdir(&dir2, &fno2);
          if (res != FR_OK || fno2.fname[0] == 0) break;
          
          uint8_t file_msg[100];
          sprintf((char*)file_msg, "  %s (%lu bytes)\r\n", fno2.fname, fno2.fsize);
          HAL_UART_Transmit(&huart1, file_msg, strlen((char*)file_msg), 100);
        }
        f_closedir(&dir2);
      } else {
        uint8_t msg[50];
        sprintf((char*)msg, "Cannot open kml dir for verify: %d\r\n", res);
        HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
      }
      
      // 延时一下，确保文件系统更新
      vTaskDelay(pdMS_TO_TICKS(500));
      
      // 不读取刚写入的文件内容，减少串口输出
      // uint8_t read_verify_msg[] = "\r\n=== Reading File Content ===\r\n";
      // HAL_UART_Transmit(&huart1, read_verify_msg, strlen((char*)read_verify_msg), 100);
      // 
      // FIL read_file_verify;
      // // 使用FA_OPEN_EXISTING | FA_READ模式，确保只打开已存在的文件
      // res = f_open(&read_file_verify, decompressed_file, FA_OPEN_EXISTING | FA_READ);
      // if (res == FR_OK) {
      //   uint8_t read_buf[100];
      //   UINT bytes_read;
      //   res = f_read(&read_file_verify, read_buf, sizeof(read_buf)-1, &bytes_read);
      //   if (res == FR_OK && bytes_read > 0) {
      //     read_buf[bytes_read] = '\0';
      //     uint8_t content_msg[150];
      //     sprintf((char*)content_msg, "File content (%d bytes): ", bytes_read);
      //     HAL_UART_Transmit(&huart1, content_msg, strlen((char*)content_msg), 100);
      //     // 以十六进制形式打印内容，便于查看非ASCII字符
      //     for (int i = 0; i < bytes_read; i++) {
      //       uint8_t hex_msg[4];
      //       sprintf((char*)hex_msg, "%02X ", read_buf[i]);
      //       HAL_UART_Transmit(&huart1, hex_msg, strlen((char*)hex_msg), 10);
      //     }
      //     uint8_t crlf[] = "\r\n";
      //     HAL_UART_Transmit(&huart1, crlf, 2, 10);
      //   } else {
      //     uint8_t msg[] = "Read failed or empty file\r\n";
      //     HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
      //   }
      //   f_close(&read_file_verify);
      // } else {
      //   uint8_t msg[80];
      //   sprintf((char*)msg, "Cannot open file for reading: %d\r\n", res);
      //   HAL_UART_Transmit(&huart1, msg, strlen((char*)msg), 100);
      //   
      //   // 尝试再次列出目录，确认文件是否真的存在
      //   uint8_t retry_msg[] = "\r\n=== Retry directory listing ===\r\n";
      //   HAL_UART_Transmit(&huart1, retry_msg, strlen((char*)retry_msg), 100);
      //   
      //   res = f_opendir(&dir2, kml_dir);
      //   if (res == FR_OK) {
      //     for (int i = 0; i < 10; i++) {
      //       res = f_readdir(&dir2, &fno2);
      //       if (res != FR_OK || fno2.fname[0] == 0) break;
      //       
      //       uint8_t file_msg[100];
      //       sprintf((char*)file_msg, "  %s (%lu bytes)\r\n", fno2.fname, fno2.fsize);
      //       HAL_UART_Transmit(&huart1, file_msg, strlen((char*)file_msg), 100);
      //     }
      //     f_closedir(&dir2);
      //   }
      // }
      
      uint8_t msg3[] = "\r\nReady for next transfer\r\n";
      HAL_UART_Transmit(&huart1, msg3, strlen((char*)msg3), 100);
    }
    
    vTaskDelay(pdMS_TO_TICKS(2));  // 进一步减少延迟，提高响应速度
  }
  /* USER CODE END StartBLEKMLTask */
}

/* Private application code --------------------------------------------------*/
/* USER CODE BEGIN Application */

/* USER CODE END Application */
